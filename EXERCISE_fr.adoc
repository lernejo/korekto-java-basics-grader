= Java : notions de base
:tip-caption: üí°
:note-caption: ‚ÑπÔ∏è
:warning-caption: ‚ö†Ô∏è
:icons: font
:hardbreaks-option:

Pr√©fix√© par ‚úîÔ∏è, des "checkpoints" pour vous aider √† v√©rifier que vous avez tout bon.

La correction est automatique, prenez donc soin de respecter les indications les plus pr√©cises.

== Objectif

Prendre en main les mot-cl√©s du langage et les structures de contr√¥le en construisant un programme accessible en ligne de commande.

== Pr√©requis

* Git
* Java 21
* (Optionnel, mais fortement recommand√©) IntelliJ edition _community_ 2024

'''

== Partie 1 - Hello World et compilation

* Cr√©er un nouveau d√©p√¥t Git **priv√©** sur la plateforme GitHub avec le nom **java_exercise_1** [.underline]#initialis√©# avec un fichier README.md (case √† cocher dans le formulaire de cr√©ation de d√©p√¥t)
* Inviter le professeur actuel comme membre du d√©p√¥t (pour la correction)
* Cloner ce nouveau d√©p√¥t en utilisant l‚Äô**url SSH**
* La branche par d√©faut est la branche **main** c‚Äôest sur celle-ci que nous allons travailler
* Cr√©er deux r√©pertoires **src** et **bin** qui contiendront respectivement les sources (fichiers *.java) et les fichiers compil√©s (fichiers *.class)
* Ajouter une classe `HelloWorld` qui contiendra une fonction `main` et qui affichera le message `Hello World` dans la sortie standard
* Cr√©er un fichier **compile.sh** qui compilera tous les fichiers sources du dossier **src** dans le dossier **bin**

[NOTE]
====
Le compilateur Java est disponible √† travers la commande `javac`.
La liste compl√®te des options de cette commande est disponible en lan√ßant `javac --help`.

L‚Äôoption qui nous int√©resse aujourd‚Äôhui est `-d` permettant de sp√©cifier le r√©pertoire dans lequel placer les fichiers compil√©s.

La commande compl√®te est donc `javac -d bin $(find ./src/ -type f -name '*.java')`
====

* Ex√©cuter le script
* Lancer ce premier programme

[NOTE]
====
La machine virtuelle Java est disponible √† travers la commande `java`.
La liste compl√®te des options de cette commande est disponible en lan√ßant `java --help`.

L‚Äôoption qui nous int√©resse aujourd‚Äôhui est `-cp` permettant de d√©clarer le chemin vers les fichiers compil√©s.

La commande compl√®te est donc `java -cp bin HelloWorld`
====

* Cr√©er un fichier **.gitignore** contenant les lignes `bin/` et `out/` afin de ne pas commiter les fichiers g√©n√©r√©s
* Indexer et commiter les fichiers nouvellement cr√©√©s, sans oublier d‚Äôajouter le bit d‚Äôex√©cution du fichier **compile.sh** √† l‚Äôindex git
* ‚úîÔ∏è Le commit doit contenir 3 fichiers :
** .gitignore
** compile.sh
** src/HelloWorld.java

## Partie 2 - Interactions en ligne de commande

A partir de l√†, il est conseill√© d‚Äôouvrir le projet (dossier contenant **src** et **bin**) avec IntelliJ afin de faciliter l‚Äô√©dition de code Java.

Nous allons √©crire un programme dont le comportement sera d√©pendant de ce que l‚Äôutilisateur √©crira dans la console.

[NOTE]
====
Pour ouvrir un projet existant avec IntelliJ, utiliser le menu **File** -> **New** -> **Project from Existing Sources** et s√©lectionner le r√©pertoire _racine_.

Ensuite pour indiquer que le r√©pertoire **src** contient des fichiers Java √† compiler, cliquer droit sur le dossier **src** et **Mark Directory as** -> **Sources Root**.

Pour sp√©cifier le JDK √† utiliser, cliquer droit sur le dossier racine et **Open Module Settings** -> **Project Settings** -> **Project** -> **SDK** et s√©lectionner JDK17 (apr√®s avoir import√© le JDK pr√©c√©demment install√© si c‚Äôest la premi√®re fois).
====

* Cr√©er une seconde classe `Launcher` contenant elle aussi une fonction `main`
* Afficher un texte de bienvenue
* Assigner √† une variable une instance de la classe `java.util.Scanner` dont le constructeur prendra comme param√®tre `System.in`

[NOTE]
====
`System.in` est l‚Äôentr√©e standard (FD 0) du programme.

De m√™me, `System.out` et `System.err` sont respectivement la sortie standard (FD 1) et la sortie d‚Äôerreur standard (FD 2).

La classe `Scanner` est un utilitaire permettant de manipuler plus simplement un `InputStream` tel que `System.in`, gr√¢ce √† des m√©thodes comme `nextLine` permettant de r√©cup√©rer la prochaine entr√©e utilisateur (valid√©e par un saut de ligne).
====

* R√©cup√©rer la prochaine entr√©e utilisateur dans une variable
* Si cette entr√©e est √©gale √† `"quit"`, laisser la m√©thode se terminer, et le programme se finir
* Sinon afficher `"Unknown command"` avant la fin du programme
* ‚úîÔ∏è le programme doit compiler (gr√¢ce au script pr√©c√©demment cr√©√©) et √™tre lan√ßable sans erreur gr√¢ce √† la commande `java -cp bin Launcher`
* Publier et pousser ces modifications sur GitHub

## Partie 3 - boucle

* Introduire une boucle afin de ne pas obliger l‚Äôutilisateur √† relancer le programme en cas de commande inconnue
* ‚úîÔ∏è Le comportement du programme doit maintenant √™tre d‚Äôafficher `"Unknown command"` en boucle, sauf si l‚Äôutilisateur √©crit **quit**
* Publier et pousser ces modifications sur GitHub

## Partie 4 - une premi√®re commande

* Ajouter la possibilit√© de taper la commande **fibo** qui demandera alors un nombre **n** √† l‚Äôutilisateur avec une question explicite et renverra la valeur de la suite de Fibonacci √† l‚Äôindex **n**

[NOTE]
====
La suite de Fibonacci peut √™tre exprim√©e comme ceci :

* F(0) = 0
* F(1) = 1
* F(n) = F(n-1) + F(n-2)

Ainsi F(10) = 55
====

[NOTE]
====
Les m√©thodes `next...` de la classe `Scanner` autres que `nextLine`, telles que `nextInt` ne consomment pas le caract√®re `\n`, il est donc n√©cessaire d‚Äôappeler `nextLine` en suivant, juste pour consommer ce caract√®re et √©viter qu‚Äôun appel ult√©rieur √† `nextLine` retourne une `String` vide.
====

* Publier et pousser ces modifications sur GitHub

## Partie 5 - une seconde commande

L‚Äôobjectif est de cr√©er un programme permettant √† l‚Äôutilisateur de connaitre, au sein d‚Äôun texte qu‚Äôil propose au programme, les 3 mots les plus utilis√©s dans ce texte.
* Ajouter la possibilit√© de taper la commande **freq** qui demandera alors un chemin de fichier √† l‚Äôutilisateur avec une question explicite
* Essayer de lire le contenu du fichier gr√¢ce √† la m√©thode statique utilitaire `java.nio.file.Files.readString` prenant en param√®tre un objet de type `Path`.
Un tel objet peut √™tre construit gr√¢ce √† la m√©thode statique `Paths.get` prenant en param√®tre un chemin de fichier
** en cas d‚Äô√©chec, afficher le message `"Unreadable file: "` suivi du nom de la classe de l‚Äôexception et de son message
** en cas de succ√®s, afficher sur une m√™me ligne les 3 mots les plus fr√©quents, un mot √©tant s√©par√© d‚Äôun autre par un espace

[NOTE]
====
Vous pouvez notamment utiliser :

* `String#replaceAll` pour remplacer tous les caract√®res de ponctuation par des espaces
* `String#toLowerCase` pour transformer toutes les majuscules en minuscules
* `String#split` pour s√©parer les mots les uns des autres et les stcoker dans un tableau
* `String#isBlank` pour savoir si un `String` est vide ou uniquement constitu√©s d‚Äôespaces
* `Arrays#stream` pour transformer un tableau en `Stream`
* `Collectors#groupingBy` pour cr√©er un `Collector` regroupant les √©l√©ments ayant une caract√©ristique commune
* `Collectors#counting` pour cr√©er un `Collector` comptant les √©l√©ments
* `Stream#limit` pour ne garder que les _n_ premiers √©l√©ments
* `Stream#sorted` pour trier les √©l√©ments selon un `Comparator`
* `Comparator#comparing` pour cr√©er un `Comparator` bas√© sur un champ. Exemple : `Comparator.comparing\((Person p) \-> p.age())` cr√©era un comparateur de `Person` bas√© sur l‚Äôage
====

* Publier et pousser ces modifications sur GitHub

## Partie 6 - un peu de _refactoring_

Le _refactoring_ est une phase du d√©veloppement qui ne change pas le comportement d‚Äôun programme mais facilite sa compr√©hension et les √©volutions futures.
Ici nous allons sortir la logique des diff√©rentes commandes dans des classes d√©di√©es, afin de ne pas avoir √† allonger la m√©thode `main`

* Cr√©er une interface `Command` avec deux m√©thodes abstraites
** `name` renvoyant un `String`
** `run` renvoyant un `boolean` et prenant en param√®tre un objet de type Scanner

* Cr√©er trois classes `Quit`, `Fibo` et `Freq` impl√©mentant `Command` et reprenant chacune le fonctionnement d‚Äôune des trois commandes existantes.
** la valeur retourn√©e par la m√©thode `name` est ce que l‚Äôutilisateur doit √©crire pour acc√©der √† la commande
** le `boolean` renvoy√© par la m√©thode `run` est ce qui d√©cidera la boucle √† s‚Äôinterrompre
* Changer le code de la fonction main en
** cr√©ant une variable de type `List<Command>` et contenant une instance de chaque impl√©mentation de `Command`
** changeant le code √† l‚Äôint√©rieur de la boucle pour
*** prendre une entr√©e utilisateur
*** chercher une commande correspondante dans la liste
*** afficher **Unknown command** en cas d‚Äô√©chec et recommencer la boucle
*** ex√©cuter la m√©thode `run` de la commande trouv√©e en lui passant la variable de type `Scanner` en param√®tre
*** si le boolean de retour de cette m√©thode est `true`, laisser le programme se terminer
*** sinon recommencer la boucle
* Publier et pousser ces modifications sur GitHub

## Partie 7 - une derni√®re commande

L‚Äôobjectif de cette partie finale est d‚Äôimpl√©menter un algorithme de pr√©diction en fonction de la fr√©quence
d‚Äôutilisation de mots d‚Äôun texte, classiquement utilis√© sur les t√©l√©phones portables.

* Cr√©er une nouvelle commande `Predict` se d√©clenchant quand l‚Äôutilisateur √©crit **predict**.
* Cette commande demandera un chemin de fichier √† l‚Äôutilisateur avec une question explicite pour apprendre le lexique du texte
* en cas d‚Äô√©chec de la lecture, afficher le message `"Unreadable file: "` suivi du nom de la classe de l‚Äôexception et de son message
* dans le cas o√π le texte est lu avec succ√®s par le programme, la commande calculera pour chaque mot, le mot le plus fr√©quent arrivant juste apr√®s
* finalement le programme demandera √† l‚Äôutilisateur d‚Äô√©crire un mot
** si le mot n‚Äôexiste pas dans le texte analys√©, afficher un message d‚Äôerreur
** si le mot existe, reconstituer et afficher la phrase statistiquement la plus plausible avec une limite de 20 mots
* Publier et pousser ces modifications sur GitHub
